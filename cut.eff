
type q = float;;
type interval = q * q;;

type real = TrivialCut of q * q | Cut of (q -> bool) * (q -> bool);;
let of_int i =  TrivialCut (float_of_int i, float_of_int i);;
let of_float f = TrivialCut (f, f);;

type 'r real_comp = effect 
  operation eval : 'r -> interval
  operation add : 'r * 'r ->  interval
end;;

let add (a1,b1) (a2,b2) = (a1+.a2,b1+.b2);;
let less (a1,b1) (a2,b2) = b1<a2
let mul (a1,b1) (a2,b2) = (a1*.a2, b1*.b2)
let sqr x = mul x x

let rec inhabitant rs x = 
  if (rs x) then x else inhabitant rs (2.*.x);;

let rec approx_inh_cut eps (l,u) (l0,u0) =
  if u0-.l0 < eps then (l0,u0)
     else let (l1,u1) = ( (l0+.u0-.eps*.0.5)/.2., (l0+.u0+.eps*.0.5)/.2.) in
	let l2 = if (l l1) then l1 else l0 in
        let u2 = if (u u1) then u1 else u0 in
        	approx_inh_cut eps (l,u) (l2,u2);;

let approx_cut eps (l,u) =
  let l0 = inhabitant l (-1.) in
  let u0 = inhabitant u 1. in
     approx_inh_cut eps (l,u) (l0,u0);;

let approx eps r = match r with
  | TrivialCut (l,u) -> (l,u)
  | Cut (l,u) -> approx_cut eps (l,u);;


let simple c eps0 = handler
 | c#add (x,y) k -> k (add (approx eps0 x) (approx eps0 y))
 | c#eval c k -> k (approx eps0 c)
 | finally c -> c
;;

let c = new real_comp in
  with simple c 0.1 handle
    c#add (of_int 1,TrivialCut (0.2, 2.5));;

let c = new real_comp in
  with simple c 0.1 handle
    c#eval (Cut ((fun x->x<0 || x*.x<2.),(fun x-> x>0 && 2.<x*.x)));;


let forward c eps0 = handler
 | c#add (x,y) k -> (fun eps -> k (add (approx eps x) (approx eps y)) eps) 
 | c#eval c k -> (fun eps -> k (approx eps c) eps)
 | val x -> (fun eps -> x) 
 | finally f -> f eps0
;;

let c = new real_comp in
  with forward c 1e-5 handle
    c#eval (Cut ((fun x->x<0 || x*.x<4.),(fun x->x>0 && 4.<x*.x)));;

let c = new real_comp in
  with forward c 1e-1 handle
    let sqrt x = Cut ((fun y -> y<0. || y*.y<x),(fun y -> y>0. && x<y*.y)) in
       c#add ((sqrt 2.),(sqrt 4.));;


