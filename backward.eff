
(*
Proof of concept. Using fake type real and approximation.
*)

type q = float;;
type interval = q * q;;
type eager_real = EReal of float | ApproxReal of interval;; (* EReal represents fake real number, ApproxReal represents it's approximation*)

type 'r real_comp = effect 
  operation f : 'r -> 'r
end;;

(* Returns an interval approximating real number accurate to 2*eps. *)
let approx eps r = match r with
  | EReal(q) -> (q-.eps, q+.eps)
  | ApproxReal(i) -> i

(* Operation f(x)=x+1 *)
let plus1 (a,b) = (a+.1.,b+.1.);;

(* Forward is simple, just calculate all the inputs with eps precision *)
let rec forward c eps0 = handler
  | c#f x k -> k (ApproxReal(plus1 (approx eps0 (x))))
;; 

let c = new real_comp;;

with forward c 0.1 handle
  (c#f (c#f (c#f (EReal 0.))), c#f (EReal 0.));;
(* - : real × rrr = (Int (2.9, 3.1), R Int (0.9, 1.1))*)


(* For backward we need to call continuation twice:
  first to get the requried eps,
  second to do the actual calculation.
  Remark: giving a good interval to the first call of continuation is probably better, but this is just a proof of concept. *)
let backward c eps0 = handler
  | val x -> (eps0, x)
  | c#f x k -> let (eps, _) = k (ApproxReal (0.,0.)) in (* fetch eps *)
               let (_, y) = k (ApproxReal(plus1 (approx eps (x)))) in (*calculate the result with it*)
                (eps/.2., y) (* return it with the eps we need *)
  | finally (eps, y) -> y  (* remove eps *)
;;

with backward c 0.16 handle
  (c#f (c#f (c#f (EReal 0.))),  c#f (EReal 0.));;
(* - : real × rrr = (Int (2.99, 3.01), R Int (0.92, 1.08)) *)


(* The following might be better but DOES NOT work *)
let fetch_eps eps0 = handler
  | val x -> print "v"; eps0
  | c#f x k -> print "h"; let eps = k x in eps/.2.
;;

with fetch_eps 0.16 handle
  (c#f (c#f (c#f (EReal 0.))));;

let calculate_backward eps0 = handler
  | c#f x k -> 
	match x with 
	  | EReal _ -> print "r";
		let eps = (with fetch_eps eps0 handle k (ApproxReal (0.,0.)))in (* fetch eps *)
	                 k (ApproxReal(plus1 (approx (eps/.2.) (x)))) (*calculate the result with it*)
	  | ApproxReal (a,b)-> print "i"; k (ApproxReal(plus1 (a,b)))
	  | lr -> k lr
;;

with calculate_backward 0.16 handle
  (c#f (c#f (c#f (EReal 0.))), c#f (EReal 0.));;


let c2 = new real_comp @ 0.16 with
  operation f x @ eps ->  ((ApproxReal(plus1 (approx eps x))),eps/.2.)
end;;

(c2#f (c2#f (c2#f (EReal 0.))), c2#f (EReal 0.));;


